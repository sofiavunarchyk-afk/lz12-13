Завдання 2

<img width="558" height="164" alt="image" src="https://github.com/user-attachments/assets/700392ce-32b2-461c-ba3b-3568e1d4a925" />

<img width="1239" height="674" alt="image" src="https://github.com/user-attachments/assets/45b94707-2196-477c-887d-1c666c67eaa6" />



## 1. Опис алгоритму

1.  **Початок.**
2.  **Підключення бібліотек:** Підключити необхідні бібліотеки для роботи з консоллю (`iostream`), файлами (`fstream`) та математичними операціями (`cmath`).
3.  **Ініціалізація змінних:**
    * Створити масив для зберігання чисел, наприклад, `int arr[100]` (із фіксованим максимальним розміром).
    * Створити лічильник `int n = 0;` для підрахунку фактичної кількості чисел, зчитаних з файлу.
4.  **Відкриття файлу:**
    * Створити об'єкт вхідного файлового потоку `ifstream fin`.
    * Спробувати відкрити файл `matrix.txt`  для читання.
5.  **Перевірка відкриття файлу:**
    * Перевірити, чи файл успішно відкрився (`if (!fin)`).
    * **Якщо ні (помилка):** Вивести повідомлення про помилку ("Не вдалося відкрити файл...") і завершити програму з кодом помилки (`return 1`).
    * **Якщо так (успіх):** Продовжити.
6.  **Цикл читання даних:**
    * Запустити цикл `while`, який триватиме, доки виконуються дві умови:
        1. Вдається зчитати число з файлу (`fin >> arr[n]`).
        2. Лічильник `n` менший за максимальний розмір масиву (`n < 100`).
    * **Всередині циклу:** Збільшити лічильник зчитаних елементів (`n++`).
7.  **Закриття файлу:** Закрити файловий потік (`fin.close()`).
8.  **Перевірка наявності даних:**
    * Перевірити, чи `n == 0` (тобто файл був порожній).
    * **Якщо так:** Вивести повідомлення ("Файл порожній...") і завершити програму.
9.  **Пошук min/max елементів:**
    * Ініціалізувати змінні `minVal = arr[0]` та `maxVal = arr[0]`.
    * Запустити цикл `for` від `i = 1` до `n - 1`.
    * **Всередині циклу:**
        * `if (arr[i] < minVal)`: оновити `minVal = arr[i]`.
        * `if (arr[i] > maxVal)`: оновити `maxVal = arr[i]`.
10. **Обчислення різниці:**
    * Обчислити `int diff = maxVal - minVal;`.
    * Вивести на екран `minVal`, `maxVal` та `diff`.
11. **Сортування масиву (Метод вибору):**
    * Запустити зовнішній цикл `for i` від `0` до `n - 2`.
    * **Всередині зовнішнього циклу:**
        * Припустити, що мінімальний елемент поточний: `int minIndex = i;`.
        * Запустити внутрішній цикл `for j` від `i + 1` до `n - 1`.
        * **Всередині внутрішнього циклу:**
            * `if (arr[j] < arr[minIndex])`: оновити `minIndex = j;`.
        * (Після внутрішнього циклу) Обміняти `arr[i]` та `arr[minIndex]` місцями (за допомогою тимчасової змінної `temp`).
12. **Виведення відсортованого масиву:**
    * Запустити цикл `for i` від `0` до `n - 1`.
    * Вивести `arr[i]` на екран.
13. **Перевірка достовірності:**
    * Обчислити `int diffSorted = arr[n - 1] - arr[0];` (різниця між останнім та першим елементом *відсортованого* масиву).
    * Порівняти `diff` (знайдений раніше) та `diffSorted`.
    * **Якщо `diff == diffSorted`:** Вивести повідомлення "Перевірка пройдена".
    * **Якщо ні:** Вивести повідомлення "Розбіжність у результатах".
14. **Кінець** (`return 0`).
